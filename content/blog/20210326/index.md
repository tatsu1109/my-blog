---
title: Clean Architectureの本 第3部
date: 2021-03-26
tags: ["Clean Architecture"]
---

[この本](https://www.amazon.co.jp/dp/B07FSBHS2V/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1)

## 第 3 部 設計の原則

- よくできたソフトウェアシステムはクリーンなコードを書くことから始まる
- そのために SOLID 原則が使える
- SOLID 原則は関数やデータ構造をどのようにクラス(機能やデータをまとめたもの)に組み込むのか、そしてクラスの相互接続をどのようにするのかといったことを教えてくれる
- SOLID 原則の目的は下記のような性質を持つ中間レベルのソフトウェア構造を作ること
  - 変更に強いこと
  - 理解しやすい事
  - コンポーネントの基盤として多くのソフトウェアシステムで利用できること
- 「中間レベルの」という言葉は SOLID 原則がモジュールレベルの開発に使われるものであることを意図している
- SOLID 原則それぞれの概要は下記のような内容
  - 単一責任の原則(SRP)...ここのモジュールを変更する理由が一つだけになるように、ソフトウェアシステムの構造がそれを使う組織の社会構造に大きな影響を受けるようにする
  - オープン・クローズドの原則(OCP)...ソフトウェアを変更しやすくするために既存のコードの変更寄りも新しいコードの追加によって、システムの振る舞いを変更できるように設計すべきである
  - リスコフの置換原則(LSP)...交換可能なパーツを使ってソフトウェアシステムを構築するならば個々のパーツが交換可能となるような契約に従わなければならないということ
  - インターフェース分離の原則(ISP)...ソフトウェアを設計する際には使っていないものへの依存を回避すべきだという原則
  - 依存関係逆転の原則(DIP)...上位レベルの方針の実装コードは下位レベルの詳細の実装コードに依存するべきではなく、逆に詳細側が方針に依存すべきだという原則

### 第 7 章 単一責任の原則

- モジュールはたった一つのアクター(ユーザー・ステークホルダーなどまとめたグループ)に対して責務を負うべきである
- モジュールとはソースファイルのことであるが、ソースファイル以外にコードをまとめる言語もあるため、そのような場合も含めた定義としてはいくつかの関数やデータをまとめた凝集性のあるものであるといったものとなる
- この凝集性によって SRP を実現するようなイメージ
- 給与システムでの例  
  Employee に関連しているが、報告先はそれぞれ別チームを対象としているメソッドを同じ Employee クラス内に作ってしまった  
  A メソッドと B メソッドで同じものを求めている部分があったため、共通ロジックとして切り出した  
  A メソッドの報告先で共通ロジックの求め方を変更する必要が出てきたため修正したが、B メソッドではその修正は必要なかったということに気付かず修正してしまった  
  結果として B メソッド側では誤った結果を和つように鳴ってしまった
- このことの原因はアクターの異なるロジックを共通の者としてしまったためであり、単一責任の原則はこういった事態を回避するため、アクターの異なるコードは分割するべきだとしている
- マージの際にも複数のアクターが単一のソースに含まれてしまっている場合、衝突が発生する可能性が高くなる
- これらの問題には様々な解決策があり、いずれも関数を別のクラスに移動するというものだ
- 解決策としてはデータを関数から切り離すものがある。データクラスにデータを格納し、別のクラスから使うようにするというものだ
- 別のクラスから切り出すだけでは切り出したクラスそれぞれのインスタンスを生成しなければいけないが、Facade パターンを利用することで解決できる
- コンポーネントレベルではこの法則は「閉鎖性共通の原則(CCP)」と呼ばれたり、アーキテクチャレベルでは「アーキテクチャの境界」を作るための「変更の軸」とも呼ばれている

### 第 8 章 OCP:オープン・クローズドの原則

- ソフトウェアの構成要素は拡張に対しては開いていて、修正に対しては閉じていなければいけない
- ソフトウェアは既存の成果物を変更せず拡張できるようにすべきであるということ
- 財務情報をウェブページに表示する場合の例  
  現在は Web ページに表示しているが、同じ内容のものを白黒プリンターで印刷したい  
  既存コードの修正は最小限、もしくはなしとしたい  
  変更理由が異なるものは単一責任の原則で分割し、依存関係を依存関係逆転の法則でまとめる  
  財務データと表示用の会計報告データは責務が異なるので分割し、出力も Web 用と印刷用で分割する  
  View、Presenter、Controller、Intersector、Database というコンポーネントに分割した  
  Intersector はアプリケーションの最上位レベルの方針であるビジネスルールを含んでおり、他のコンポーネントの変更に依存しないようにする  
  また、View は最下位レベルの概念であり、他のコンポーネントより保護レベルは低くなる
- このようにアーキテクチャレベルのオープン・クローズドの原則とは、いつどのような理由でどのように変更するかを考えて機能を分割するもの
- そして分割した機能を階層構造にまとめ、上位レベルのコンポーネントは下位レベルのコンポーネントが変更された場合も変更する必要はないようにする
- 変更する必要が無いようにするため、インターフェースを挟んで依存関係の逆転や使用する処理についての情報の隠ぺいを行う
- 下位レベルの変更が上位レベルに影響を及ぼさないようにすることが第一だが、下位レベルも上位レベルの変更から保護する必要がある
-

### 第 9 章 LSP:リスコフの置換原則

- 定義としては「置換可能な性質である：S 型のオブジェクト o1 の各々に、対応する T 型のオブジェクト o2 が 1 つ存在し、T を使って定義されたプログラム P に対して o2 の代わりに o1 を使っても P の振る舞いが変わらない場合、S は T の派生型であると言える」というもの
- リスコフの置換原則は経書の使い方の指針となるものだと考えられていた(継承を使って実装したオブジェクトを別のものに入れ替えても処理が成立するかどうか)
- しかし、今ではインターフェースと実装に関するソフトウェア設計の原則ともなっている

### 第 10 章 ISP:インターフェース分離の原則

- 静的型付き言語では使っていないメソッドがあるクラスを使用している場合は、使っていないメソッドに変更が掛かった場合も再コンパイルや再デプロイが必要となる
- これは使っていないものに対して依存しているという状態なので、使っている操作をインターフェースに分離するなど行って依存を取り除いた方が良い
- 動的型付き言語ではこのような再コンパイルなどの依存は存在しないため、より疎結合なシステムを作ることができる
- アーキテクチャレベルにおいても、特定の DB に依存したフレームワークなどがある場合、DB に変更があった際にフレームワーク自体も再デプロイが必要になってしまう
- 必要としないものには依存しないようにしていくことが必要

### 第 11 章 DIP:依存関係逆転の原則

- ソースコードの依存関係が抽象だけを参照しているものが柔軟なシステムと言える
- ただし、全ての具象への依存を取り除くことはできないため、OS やプラットフォーム周りへの依存は許容することが多い
- システム内の変化しやすい具象へは依存させないようにする
- 抽象インターフェースの変更は具象実装の変更に繋がるが、具象実装の変更が抽象インターフェースの変更に繋がることはあまりない
- このことから抽象インターフェースの変更はできるだけ抑えるようにしている
- 変化しやすい具象への依存を避け、安定した抽象インターフェースへ依存させるためのコーディングレベルのベストプラクティス
  - 変化しやすい具象クラスを参照しない...Abstract Factory パターンを用いることで回避できる
  - 変化しやすい具象クラスを継承しない
  - 具象関数をオーバーライドしない
  - 変化しやすい具象を名指しで参照しない
- 上記のルールに従おうとすると具象オブジェクトを精鋭する際に特別な処理が必要となる。これを Abstract Factory パターンを通して解消できる
- 抽象コンポーネントには全ての上位レベルのビジネスルールが含まれ、具象コンポーネントにはこれらのビジネスルールが操作する実装の詳細が含まれる
- 実際の処理の流れはソースコードの依存性とは逆向きとなるため依存関係逆転の原則となっている
- ほとんどのシステムには依存関係逆転の原則を見たさない具象コンポーネントが存在し、基本的に main コンポーネントとなる
