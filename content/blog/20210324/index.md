---
title: Clean Architectureの本 第1部、第2部
date: 2021-03-24
tags: ["Clean Architecture"]
---

[この本](https://www.amazon.co.jp/dp/B07FSBHS2V/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1)

## 序文

- ソフトウェアアーキテクチャのルールはどれも同じ
- 実際に書いているコードは「順次」「選択」「反復」を組み合わせた者に過ぎず、書いているコードが変わらないのであればどんな種類のシステムでもルールは同じとなるはず
- 昔はそのルールをつかみ切れていなかったため、おかしなコードを書いていたりしたが、今はつかむことができたため、そのルールに関して本書に記載している

## 第 1 部 イントロダクション

- ソフトウェアを一度動かすことは簡単だが、正しくすることは難しい
- ソフトウェアを正しくすることで開発や捕手で必要な人材をわずかにすることができる

### 第 1 章 設計とアーキテクチャ

- 設計とアーキテクチャという言葉は使い分けられているが、実質では何も違いはない。
- 通常アーキテクチャは下位レベルの詳細とは切り離された文脈で使用されていて、設計は下位レベルの構造や意思決定に使われている
- だが下位レベルの詳細も上位レベルの構造も全体の設計の一部となっており、両者を明確に区別することはできない
- それらが連続した構造を作り、システムの構造を定義するための決定の連続として続いている
- この決定の目的は求められるシステムを構築・保守するために必要な人材を最小限に押さえることである
- この章での例は適切な決定ができなかったため、構築・保守のリソースが膨れてしまった例を示している

### 第 2 章 2 つの価値のお話

- 振る舞いと構造
- 振る舞い...マシンがステークホルダーのためにお金を生み出したり節約できるようにする
- 構造(アーキテクチャ)...ソフトウェアの構造
- ソフトウェアは簡単に変更可能(ソフト)でなければ行けない
- 変更の難易度は変更の形状ではなく、変更のスコープに比例するようにしなければいけない
- ビジネスマネージャーからはソフトウェアシステムが動作すること(振る舞い)が重要だと答えられる
- 「重要度と緊急度のマトリックス」という考えでは重要なことが緊急になるわけではないと述べられている
- コードのアーキテクチャは重要、コードの振る舞いは緊急に属する
- 重要なことが緊急になるわけではないので緊急なことを重視して重要なことを無視してはいけない
- ビジネスマネージャーにはシステムのアーキテクチャの重要性を評価できないので、
- ソフトウェア開発者は機能の緊急性よりもアーキテクチャの重要性を主張する責任がある
- アーキテクチャの重要性＝機能を簡単に開発・変更・拡張できるアーキテクチャを構築すること

## 第 2 部 構成要素から始めよ：プログラミングパラダイム

- プログラミングパラダイムの説明

### 第 3 章 パラダイムの概要

- 構造化プログラミング...直接的な制御の移行に規律を課すもの(制限のない Jump は有害であるとし、代替の構文を用意した)
- オブジェクト思考プログラミング...間接的な制御の移行に規律を課すもの(変数が存在し続けられることに気付き、ポリモーフィズムの発見に繋がった)
- 関数型プログラミング...代入に規律を課すもの(シンボルの値は変化しないという概念)
- これらのパラダイムではプログラマから能力を削除している=何をするべきではないかを伝えている(goto 文、関数ポインタ、代入)

### 第 4 章 構造化プログラミング

- 構造化プログラミングはモジュールを証明可能な単位に再帰的に分割することを可能にする
- 構造化プログラミングの価値を高めるのは反証可能なプログラミングの単位を作成する能力
- そのため、現代の言語では無制限の goto 文がサポートされていない
- これはアーキテクチャレベルで機能分割がベストプラクティスであると考えられている理由である
- ソフトウェアアーキテクトは簡単に反証できるモジュール、コンポーネント、サービスを定義しようとしていて、そのため、さらに上位のレベルにおいては構造化プログラミングのような制限を課している

## 第 5 章 オブジェクト指向プログラミング

- オブジェクト指向とは何なのか
- カプセル化...多くの OO 言語は強制的なカプセル化をもっていない(C 言語の方がカプセル化する書き方を強制していた)
- 継承...OO の登場以前から使われてはいたが、OO 言語のもの程便利なものではなかった
- ポリモーフィズム...UNIX の IO ドライバでは 5 つの標準機能を提供することが求められていて、C 言語でその IO ドライバの標準機能を実装していることを用いて、ポリモーフィズムしていると著している(関数へのポインタの応用)
- OO は新しいものを提供しているわけではない
- ただし、関数ポインタを用いてポリモーフィズムの振る舞いを行う場合はポインタを経由して関数を呼び出す、という規約を覚えておかないとバグの追跡と排除が難しくなるという危険性がある
- OO 言語では上記の規約を排除し(間接的な制御の移行に規律を課して)、その危険性を回避できるようにしている
- ポリモーフィズムの優れた点の例としては、IO デバイスの copy プログラムの実装を例として挙げている
- IO デバイスとして新しいデバイスを使用した際に、copy プログラムは IO プログラムで 5 つの標準機能を実装している想定で作られているため、copy プログラムを改修する必要はない
- これはプラグインアーキテクチャといったもので、プログラムはデバイス非依存にするべきという考え方で作られている
- このような別のものに非依存にするといった考え方をプログラムに対してはしてこなかったが、OO によってできるようになってきた
- ポリモーフィズム以前では、プログラムは上位レベルが下位レベルの関数を呼び出すという制御の流れに従っていた。このため、制御の流れはシステムの振る舞いによって決まり、ソースコードの依存関係は制御の流れによって決まっていた
- ポリモーフィズム以後では、インターフェースを軽油して関数を実行することで、制御の流れと依存関係を逆転させることができる。(上位レベルは特定の下位レベルを指定せず関数を実行でき、下位レベルは上位レベルを指定しない)
- このポリモーフィズムの依存関係逆転を用いることでシステムのソースコードの依存関係の方向を絶対的に制御できるようになる
- 依存関係の方向を制御することで、UI やデータベースなどの外の要因をビジネスロジックに対して依存させる、つまりビジネスロジックのプラグインアーキテクチャのように扱うことができるようになる

## 第 6 章 関数型プログラミング

- 関数型言語の変数は変化しない
- 変化しないということで競合状態、デッドロック状態、並行更新といった問題を解決できる
- ストレージとプロセッサ速度が無限であれば不変性を実際に扱うことはできるが、現実は妥協する必要がある。妥協した例が下記のようなもの
- 可変性の分離...アプリケーションのサービスを可変コンポーネントと不変コンポーネントに分離すること
- イベントソーシング...銀行口座の口座残高の例で、これまでの全ての取引を保存していると考えれば可変変数は不要だが、それを行うためには無限のリソースが必要である。ただし、このような仕組みをアプリケーションの寿命機関のみ動作させることは可能と鳴ってきている。イベントソーシングとは、そういった状態ではなく取引を保存するという戦略である。ソースコード管理でも同じようなことをやっている
